# План рефакторинга проекта Auto-Slide

Документ описывает пошагово каждый этап рефакторинга и расширения проекта. В файле нет кода — только инструкции, критерии приёма, риски и рекомендуемые проверки.

Цели рефакторинга

- Сделать код модульным и соответствующим SRP/DRY/YAGNI.
- Перевести проект на понятную структуру пакетов, оставив в корне только `main.py` и шаблон(ы).
- Обеспечить поддержку заметок в формате Markdown (MD) и возможность указывать абсолютные и относительные пути в JSON (относительные — относительно файла JSON).
- Добавить CLI с командами `generate` и `analyze`, `--help`.
- Обеспечить расширяемость макетов/шаблонов и контроль имени выходного файла.

Предварительные условия

- Убедиться, что в репозитории есть рабочая копия `template.pptx` (если нет — отметить как TODO и подготовить шаблон вручную).
- Сохранить текущие файлы исходников (`one.py`, `two.py`, `three.py`) в отдельной папке `archive/` на случай отката.
- Иметь доступ к окружению с установленными зависимостями (список в `requirements.txt`).

Формат описания этапов

Для каждого этапа ниже указано:

- Что сделать (шаги)
- Результат (артефакты)
- Критерии приёма (как проверить)
- Оценка времени (ориентировочно)
- Риски и рекомендации

---

Этап 1 — Подготовка структуры проекта

Что сделать:

1. Создать корневую точку входа `main.py` (пустой файл с заглушкой для CLI).
2. Создать пакеты/папки: `config/`, `core/`, `models/`, `io_handlers/`, `cli/`.
3. Добавить `__init__.py` в каждую папку (чтобы они были распознаваемыми пакетами).
4. Создать папку `doc/plan/` (этот шаг уже выполняется) и поместить сюда текущий план.

Результат:

- Появится ожидаемая структура каталогов; проект готов к перемещению кода по пакетам.

Критерии приёма:

- Папки и `__init__.py` существуют в репозитории.
- `main.py` присутствует в корне.

Оценка времени: 10–20 минут.

Риски: минимальны.

---

Этап 2 — Описание моделей данных (контракты)

Что сделать:

1. Описать dataclass/структуру конфигурации, отражающую JSON (PresentationConfig, SlideConfig и т.д.).
2. Зафиксировать контракт: возможные поля JSON, их типы и обязательность.
3. Задокументировать правила разрешения путей (абсолютные — как есть; относительные — относительно JSON).

Результат:

- Документ с формальным описанием модели конфигурации и примерами JSON (в `doc/plan/` или `doc/`).

Критерии приёма:

- Для каждого поля указаны тип, обязательность и формат (например, `notes_source` может быть `inline` или путь к `.md`).
- Пример рабочего JSON с относительными и абсолютными путями.

Оценка времени: 30 минут.

Риски: если JSON содержит произвольные поля, потребуется решить стратегию игнорирования/валидации.

Рекомендация: использовать простой контракт и расширять его по мере потребностей.

---

Этап 3 — IO и разрешение путей

Что сделать:

1. Спроектировать компонент, ответственный за чтение JSON (ConfigLoader) и его валидацию.
2. Спроектировать PathResolver: логика, где относительные пути разрешаются относительно директории JSON.
3. Спроектировать ResourceLoader: чтение `.md` и изображений, преобразование входных путей в абсолютные.

Результат:

- Документ с описанием интерфейсов (какие методы, входные/выходные значения, поведение при ошибках).

Критерии приёма:

- Чёткая спецификация: как обрабатывать отсутствующие файлы, какие исключения выбрасывать, поведение при неверных путях.
- Примеры: JSON с относительными путями и ожидаемые абсолютные результаты.

Оценка времени: 30–45 минут.

Риски: платформозависимые особенности путей (Windows vs Unix) — описать правила нормализации путей.

---

Этап 4 — Очистка Markdown (заметки)

Что сделать:

1. Прописать контракт для очистителя Markdown: вход — текст Markdown, выход — чистый многострочный текст для заметок докладчика.
2. Определить, какие конструкции нужно убирать/сохранять (списки — превращать в строки с маркерами или в слитный текст, код — удалить/заменить на маркеры и т.д.).
3. Описать поведение при ошибках и тестовые кейсы (пустой файл, большие файлы, необычные символы).

Результат:

- Документ с правилами трансформации Markdown в текст заметок и набор тест-кейсов.

Критерии приёма:

- Набор примеров вход/ожидаемый выход для очистителя на 8–10 кейсов.

Оценка времени: 20–30 минут.

Риски: потеря смысловой структуры заметок при чрезмерном упрощении — аккуратно выбирать правила.

---

Этап 5 — Логика размещения на слайде (макеты)

Что сделать:

1. Описать концепцию «LayoutBlueprint» — что это должно содержать (имя макета, список позиций для картинок, ограничения размеров).
2. Сформировать описание того, как выбирать макет для слайда (поле `layout_type` в JSON).
3. Описать поведение при несовпадении числа изображений и требуемых размещений (игнорировать лишние, заполнять недостающие пустыми областями или ставить плейсхолдер).

Результат:

- Документ с полными правилами размещения: координаты считаются в единицах PPTX (см/дюймы) и правила масштабирования изображений.

Критерии приёма:

- Описано поведение для 3–5 типов макетов, включая правила масштабирования и выравнивания.

Оценка времени: 45–60 минут.

Риски: придётся согласовать координаты с реальным шаблоном — предусмотреть этап проверки с `analyze`.

---

Этап 6 — Построитель презентации (оркестратор)

Что сделать:

1. Спроектировать PresentationBuilder: входы, шаги (создать презентацию из шаблона, пройти по слайдам конфигурации, добавить контент, добавить заметки, сохранить).
2. Описать контракт: какие ошибки он может выбрасывать, как возвращает статус/логи.
3. Определить поведение при частичной ошибке (например, не найдена картинка на одном из слайдов): продолжать с предупреждением или прерывать весь процесс.

Результат:

- Детальное описание алгоритма сборки презентации и список возможных состояний завершения.

Критерии приёма:

- Описаны все шаги оркестратора и ожидаемые итоговые артефакты.

Оценка времени: 60–90 минут.

Риски: многочисленные внешние ошибки (файлы, доступы). Рекомендация: логировать и продолжать где разумно.

---

Этап 7 — CLI и UX командной строки

Что сделать:

1. Описать интерфейс командной строки: команды `generate`, `analyze`, `help` и их параметры (config, --output, --template и т.д.).
2. Описание вывода и уровней логирования (info/warn/error).
3. Прописать UX для ошибок (чёткие сообщения) и exit-коды (0 — успех, >0 — ошибка).

Результат:

- Документ с примерами использования CLI и ожидаемым выводом.

Критерии приёма:

- Примеры команд в README и корректный вывод `--help`.

Оценка времени: 30–45 минут.

Риски: выбор библиотеки для CLI (если планируете `click` — добавить в требования).

---

Этап 8 — Тестирование и базовая валидация

Что сделать:

1. Сформировать набор unit-тестов для ключевых чистых функций: PathResolver, MarkdownCleaner, Image dimension calculator.
2. Написать интеграционный тест «end-to-end» на минимальном JSON: генерировать презентацию и проверить, что файл создан.
3. Проверить сценарии с относительными и абсолютными путями.

Результат:

- Набор тест-кейсов и инструкции по запуску.

Критерии приёма:

- Все unit-тесты проходят локально.
- Интеграционный тест создаёт корректный PPTX и уведомляет об успехе.

Оценка времени: 60–120 минут (в зависимости от уровня покрытия).

Риски: окружение — убедитесь, что зависимости установлены.

---

Этап 9 — Документация и примеры

Что сделать:

1. Обновить `doc/README.md` или добавить `doc/usage.md` с примерами JSON и примерами CLI.
2. Добавить образцы JSON конфигов в `doc/samples/`.
3. Объяснить стратегию миграции существующих проектов (как конвертировать старые JSON/скрипты).

Результат:

- Набор документов с примерами и краткими инструкциями.

Критерии приёма:

- Пользователь может с помощью README сгенерировать презентацию из образца JSON.

Оценка времени: 30–60 минут.

Риски: необходимо поддерживать документацию в актуальном состоянии.

---

Этап 10 — Cleanup и деплой изменений

Что сделать:

1. Переместить старые файлы в `archive/` или удалить после подтверждения.
2. Обновить `requirements.txt` (например, добавить `click`, если будет использоваться).
3. Обновить `.gitignore` при необходимости.
4. Прописать миграционный чек-лист перед мёрджем в основную ветку: код ревью, тесты, smoke tests.

Результат:

- Чистый репозиторий с новой структурой и документацией о миграции.

Критерии приёма:

- Новый код покрывает старую функциональность, тесты проходят, документация обновлена.

Оценка времени: 30 минут.

Риски: потеря работы — обязательно бэкапировать исходники.

---

План внедрения и ориентировочный таймлайн

День 1: Этапы 1–3 (структура, модели, IO)
День 2: Этапы 4–6 (очиститель, image logic, builder)
День 3: Этапы 7–9 (CLI, тесты, документация)
День 4: Этап 10 и доработки/фикс багов

Проверки перед мёрджем

- Все unit-тесты зелёные
- Основной сценарий `generate` успешно создаёт PPTX
- `analyze` корректно показывает заполнители шаблона
- Документация содержит пример использования

Контрольные точки и артефакты

- Коммит после завершения каждого этапа
- Pull request на каждую крупную группу изменений (например, «models+io», «core», «cli+tests»)

Примечания

- Если в проекте ожидаются дополнительные фичи (несколько шаблонов, плагины макетов) — после базовой миграции продумать API-плагины.
- Сохраняйте неизменность public API там, где ожидается совместимость.

---

Конец плана.
